<!DOCTYPE html>
<html lang="en"><!DOCTYPE html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FSP Algorithm - Find Similar Patterns | Next Generation Compression</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #4b6cb7;
            --secondary: #182848;
            --accent: #ff6b6b;
            --light: #f8f9fa;
            --dark: #343a40;
            --success: #28a745;
            --info: #17a2b8;
            --warning: #ffc107;
            --danger: #dc3545;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            background-attachment: fixed;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: linear-gradient(to right, var(--secondary), var(--primary));
            color: white;
            padding: 2rem;
            border-radius: 10px;
            margin-bottom: 2rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        
        header h1 {
            font-size: 3rem;
            margin-bottom: 0.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .github-badge {
            display: inline-block;
            background: rgba(0, 0, 0, 0.2);
            padding: 5px 15px;
            border-radius: 20px;
            margin-top: 15px;
            font-size: 0.9rem;
        }
        
        .github-badge a {
            color: white;
            text-decoration: none;
        }
        
        .github-badge i {
            margin-right: 5px;
        }
        
        .nav {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            background: white;
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 2rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }
        
        .nav a {
            color: var(--dark);
            text-decoration: none;
            padding: 0.5rem 1rem;
            margin: 0.5rem;
            border-radius: 5px;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        .nav a:hover {
            background: var(--primary);
            color: white;
        }
        
        .section {
            background: white;
            border-radius: 10px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }
        
        .section h2 {
            color: var(--primary);
            border-bottom: 2px solid var(--primary);
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
        }
        
        .section h2 i {
            margin-right: 10px;
        }
        
        .section h3 {
            color: var(--secondary);
            margin: 1.5rem 0 1rem 0;
        }
        
        .card {
            background: var(--light);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border-left: 4px solid var(--primary);
        }
        
        .card.success {
            border-left-color: var(--success);
        }
        
        .card.warning {
            border-left-color: var(--warning);
        }
        
        .card.info {
            border-left-color: var(--info);
        }
        
        .card.danger {
            border-left-color: var(--danger);
        }
        
        .card h4 {
            color: var(--secondary);
            margin-bottom: 0.5rem;
        }
        
        pre {
            background: #2b303b;
            color: #dee2e6;
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1.5rem 0;
            font-family: 'Fira Code', monospace;
            line-height: 1.5;
        }
        
        code {
            background: #f1f3f5;
            color: #e83e8c;
            padding: 2px 5px;
            border-radius: 4px;
            font-family: 'Fira Code', monospace;
        }
        
        .code-comment {
            color: #8a8a8a;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }
        
        .comparison-table th, .comparison-table td {
            border: 1px solid #dee2e6;
            padding: 0.75rem;
            text-align: left;
        }
        
        .comparison-table th {
            background-color: var(--primary);
            color: white;
        }
        
        .comparison-table tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        
        .comparison-table tr:hover {
            background-color: #e9ecef;
        }
        
        .btn {
            display: inline-block;
            background: var(--primary);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            background: var(--secondary);
            transform: translateY(-2px);
        }
        
        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin: 1.5rem 0;
        }
        
        .feature {
            background: var(--light);
            padding: 1.5rem;
            border-radius: 8px;
            text-align: center;
        }
        
        .feature i {
            font-size: 2.5rem;
            color: var(--primary);
            margin-bottom: 1rem;
        }
        
        .feature h4 {
            color: var(--secondary);
            margin-bottom: 0.5rem;
        }
        
        .footer {
            text-align: center;
            padding: 2rem;
            background: var(--secondary);
            color: white;
            border-radius: 10px;
            margin-top: 2rem;
        }
        
        .footer a {
            color: #ffcc00;
            text-decoration: none;
        }
        
        .footer a:hover {
            text-decoration: underline;
        }
        
        .changelog {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
        }
        
        .changelog-version {
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #dee2e6;
        }
        
        .changelog-version:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .changelog-version h4 {
            color: var(--primary);
            margin-bottom: 0.5rem;
        }
        
        .changelog-version ul {
            margin-left: 1.5rem;
        }
        
        .changelog-version li {
            margin-bottom: 0.5rem;
        }
        
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }
            
            .nav {
                flex-direction: column;
            }
            
            .nav a {
                margin: 0.25rem 0;
                text-align: center;
            }
            
            .features {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>FSP Algorithm</h1>
            <p>Find Similar Patterns - Next Generation Data Compression</p>
            <div class="github-badge">
                <a href="https://github.com/Ferki-git-creator/fsp" target="_blank">
                    <i class="fab fa-github"></i> View on GitHub
                </a>
            </div>
        </header>

        <div class="nav">
            <a href="#about"><i class="fas fa-info-circle"></i> About</a>
            <a href="#how-it-works"><i class="fas fa-cogs"></i> How It Works</a>
            <a href="#implementation"><i class="fas fa-code"></i> Implementation</a>
            <a href="#features"><i class="fas fa-star"></i> Features</a>
            <a href="#examples"><i class="fas fa-list-ol"></i> Examples</a>
            <a href="#comparison"><i class="fas fa-balance-scale"></i> Comparison</a>
            <a href="#applications"><i class="fas fa-rocket"></i> Applications</a>
            <a href="#changelog"><i class="fas fa-history"></i> Changelog</a>
        </div>

        <section id="about" class="section">
            <h2><i class="fas fa-info-circle"></i> About the FSP Algorithm</h2>
            <p>The FSP (Find Similar Patterns) algorithm is a revolutionary data compression technique designed to efficiently reduce data size by identifying and leveraging similar patterns within the data. Unlike traditional compression methods, FSP specializes in working with small to medium-sized data volumes where conventional algorithms often introduce significant overhead.</p>
            
            <div class="card info">
                <h4>Version 2.1 - Next Level FSP</h4>
                <p>FSP is a universal data compression algorithm for any files or byte streams. Its core idea is to find similar patterns in data and store only the differences or references, avoiding duplication. Version 2.1 adds precise byte-level storage, automatic pattern length selection, optimized reference handling, and extended max pattern lengths for long repeats.</p>
            </div>
            
            <div class="card success">
                <h4>Key Innovation</h4>
                <p>FSP introduces automatic pattern length selection, optimized reference handling, and extended pattern matching capabilities that make it exceptionally efficient for data with repeated sequences. The algorithm minimizes overhead by storing patterns that repeat only once as LITERAL instead of REF.</p>
            </div>
        </section>

        <section id="how-it-works" class="section">
            <h2><i class="fas fa-cogs"></i> How the FSP Algorithm Works</h2>
            <p>The FSP algorithm operates on the principle of identifying repeated patterns in data and replacing subsequent occurrences with references to the first occurrence. This approach significantly reduces redundancy without the overhead of traditional compression methods.</p>
            
            <h3>Compression Process</h3>
            <ol>
                <li><strong>Pattern Discovery</strong> - The algorithm scans the input data to identify repeated patterns of lengths between the configured minimum and maximum values (typically 3-5 characters).</li>
                <li><strong>Automatic Pattern Selection</strong> - The algorithm automatically selects the optimal pattern length (3-5 characters) that maximizes repeated patterns while avoiding overhead from too-short sequences.</li>
                <li><strong>Reference Creation</strong> - For each repeated pattern, the algorithm creates a reference pointing to the first occurrence of that pattern. Patterns that repeat only once are stored as LITERAL to minimize REF overhead.</li>
                <li><strong>Byte-Exact Storage</strong> - REF and LITERAL are stored as raw bytes for exact size tracking. LITERAL stores 1 byte per character. REF stores position and length information.</li>
                <li><strong>Output Generation</strong> - The compressed output consists of a combination of literal data (for unique patterns) and references (for repeated patterns) and can be saved directly to a file.</li>
            </ol>
            
            <h3>Decompression Process</h3>
            <ol>
                <li><strong>Parsing</strong> - The decompressor reads the compressed data, parsing literal values and references.</li>
                <li><strong>Reconstruction</strong> - For each reference, the decompressor looks up the referenced pattern and inserts it into the output.</li>
                <li><strong>Output</strong> - The original data is perfectly reconstructed by combining literal values and resolved references.</li>
            </ol>
            
            <div class="card">
                <h4>LEGO Box Analogy</h4>
                <p>Think of FSP as a LEGO box organization system:</p>
                <ol>
                    <li>Pick one construction as the base.</li>
                    <li>Store similar constructions as base + differences only.</li>
                    <li>Unique constructions remain unchanged.</li>
                    <li>You save space by storing only new details instead of the entire construction.</li>
                </ol>
            </div>
            
            <div class="card">
                <h4>Mathematical Foundation</h4>
                <p>The algorithm uses sequence comparison at the byte or character level. For a base string B and target string T, the compression efficiency is determined by the number and length of common substrings.</p>
                <p>The compression ratio CR is defined as: CR = Original Size / Compressed Size</p>
                <p>Where Compressed Size = Size(Literals) + Size(References)</p>
            </div>
        </section>

        <section id="implementation" class="section">
            <h2><i class="fas fa-code"></i> Implementation Details</h2>
            <p>The FSP algorithm is implemented in Python but can be easily ported to other programming languages. Below is the core implementation of the pattern finding and compression logic.</p>
            
            <h3>Pattern Discovery Function</h3>
            <pre><code>def find_patterns(text, min_len=3, max_len=5):
    """Find repeated patterns in text and return dictionary with positions"""
    patterns = defaultdict(list)
    n = len(text)
    
    # Search for patterns of all lengths between min_len and max_len
    for L in range(min_len, max_len + 1):
        for i in range(n - L + 1):
            s = text[i:i+L]
            patterns[s].append(i)
    
    # Keep only patterns that occur more than once
    return {p: pos for p, pos in patterns.items() if len(pos) > 1}</code></pre>
            
            <h3>Compression Function (Byte-Level)</h3>
            <pre><code>def fsp_compress(text, min_len=3, max_len=5):
    """Compress text using the FSP algorithm with byte-level storage"""
    patterns = find_patterns(text, min_len, max_len)
    compressed = bytearray()
    i = 0
    
    while i < len(text):
        best_pat = None
        best_pos = None
        best_len = 0
        
        for pat, positions in patterns.items():
            if i in positions and len(pat) > best_len:
                # Find first previous occurrence
                prev_positions = [p for p in positions if p < i]
                if prev_positions:
                    best_pat = pat
                    best_pos = prev_positions[-1]
                    best_len = len(pat)
        
        if best_pat and best_pos is not None:
            # REF: 2 bytes pos + 1 byte len
            compressed += struct.pack(">HB", best_pos, best_len)
            i += best_len
        else:
            # LITERAL: 1 byte
            compressed.append(ord(text[i]))
            i += 1
            
    return compressed</code></pre>
            
            <h3>Decompression Function (Byte-Level)</h3>
            <pre><code>def fsp_decompress(compressed):
    """Decompress FSP-compressed data with byte-level storage"""
    output = []
    i = 0
    
    while i < len(compressed):
        # Check if next 3 bytes could be a REF
        if i + 3 <= len(compressed):
            pos, length = struct.unpack(">HB", compressed[i:i+3])
            # Valid REF: pos < len(output)
            if pos < len(output):
                output.extend(output[pos:pos+length])
                i += 3
                continue
        # Otherwise, literal
        output.append(compressed[i])
        i += 1
        
    return bytes(output).decode("ascii")</code></pre>
            
            <h3>Pattern Length Guidelines</h3>
            <ul>
                <li><strong>Automatic min_len</strong> = 3–5 characters</li>
                <li><strong>Max pattern length</strong> = 5–6 characters for longer repeats</li>
                <li><strong>Short repetitive text</strong> → min_len=3, max_len=5</li>
                <li><strong>Longer logs/technical text</strong> → min_len=4, max_len=6</li>
            </ul>
            
            <div class="card warning">
                <h4>Implementation Note</h4>
                <p>The algorithm can be optimized for specific use cases by adjusting the min_len and max_len parameters. For highly repetitive data, increasing max_len can improve compression ratio. For binary data, the algorithm compares bytes instead of characters.</p>
            </div>
        </section>

        <section id="features" class="section">
            <h2><i class="fas fa-star"></i> Features & Advantages</h2>
            
            <div class="features">
                <div class="feature">
                    <i class="fas fa-bolt"></i>
                    <h4>High Speed</h4>
                    <p>Linear complexity O(n) for most operations</p>
                </div>
                
                <div class="feature">
                    <i class="fas fa-compress-arrows-alt"></i>
                    <h4>Efficient Compression</h4>
                    <p>Excellent compression ratio for repetitive data</p>
                </div>
                
                <div class="feature">
                    <i class="fas fa-cogs"></i>
                    <h4>Simple Implementation</h4>
                    <p>No complex data structures or mathematical operations</p>
                </div>
                
                <div class="feature">
                    <i class="fas fa-exchange-alt"></i>
                    <h4>Versatility</h4>
                    <p>Works with any data type (text, binary, etc.)</p>
                </div>
                
                <div class="feature">
                    <i class="fas fa-sliders-h"></i>
                    <h4>Adaptive Pattern Length</h4>
                    <p>Automatically selects optimal pattern lengths</p>
                </div>
                
                <div class="feature">
                    <i class="fas fa-code-branch"></i>
                    <h4>Streaming Support</h4>
                    <p>Can be adapted for streaming data processing</p>
                </div>
                
                <div class="feature">
                    <i class="fas fa-ruler"></i>
                    <h4>Byte-Exact Storage</h4>
                    <p>REF and LITERAL stored as raw bytes for exact size tracking</p>
                </div>
                
                <div class="feature">
                    <i class="fas fa-file-export"></i>
                    <h4>Direct File Output</h4>
                    <p>Compressed data can be saved directly to files</p>
                </div>
            </div>
            
            <h3>Technical Advantages</h3>
            <ul>
                <li>Minimal overhead for service information</li>
                <li>Ability to process data in streams</li>
                <li>Easy adaptation for working with binary data</li>
                <li>Support for incremental compression</li>
                <li>No dictionary storage requirements</li>
                <li>Lossless compression - perfect data reconstruction</li>
                <li>Cross-language implementable (Python, C, C++, Java, Rust, Go, etc.)</li>
                <li>Testable with speed measurement for compression and decompression</li>
            </ul>
        </section>

        <section id="examples" class="section">
            <h2><i class="fas fa-list-ol"></i> Detailed Examples</h2>
            
            <h3>Example 1: Simple Text Compression</h3>
            <div class="card">
                <h4>Input Text</h4>
                <p>"Hello friend! Hello fiend! Hello friends! Hello friend!"</p>
                
                <h4>Compression Process</h4>
                <p>The algorithm identifies repeated patterns like "Hello", "friend", and "ello " and replaces subsequent occurrences with references. Patterns that repeat only once are stored as LITERAL to minimize REF overhead.</p>
                
                <h4>Compressed Output</h4>
                <pre>('LITERAL', 'H')
('LITERAL', 'e')
('LITERAL', 'l')
('LITERAL', 'l')
('LITERAL', 'o')
('LITERAL', ' ')
('LITERAL', 'f')
('LITERAL', 'r')
('LITERAL', 'i')
('LITERAL', 'e')
('LITERAL', 'n')
('LITERAL', 'd')
('LITERAL', '!')
('LITERAL', ' ')
('REF', 0, 5)  // Reference to "Hello"
('LITERAL', ' ')
('LITERAL', 'f')
('REF', 8, 5)  // Reference to "riend"
// ... additional references</pre>
                
                <h4>Compression Results</h4>
                <p>Original size: 55 bytes</p>
                <p>Compressed size: 33 bytes</p>
                <p>Compression ratio: 1.67</p>
            </div>
            
            <h3>Example 2: Binary Data Adaptation</h3>
            <div class="card">
                <p>The algorithm can be adapted for binary data by comparing bytes instead of characters:</p>
                <pre><code>def fsp_compress_binary(data, min_len=3, max_len=5):
    """Compress binary data using FSP algorithm"""
    patterns = defaultdict(list)
    n = len(data)
    
    # Search for patterns of all lengths between min_len and max_len
    for L in range(min_len, max_len + 1):
        for i in range(n - L + 1):
            pattern = data[i:i+L]
            patterns[pattern].append(i)
    
    # Keep only patterns that occur more than once
    patterns = {p: pos for p, pos in patterns.items() if len(pos) > 1}
    
    compressed = bytearray()
    i = 0
    
    while i < n:
        # Try to find the longest pattern starting at i
        best_pat = None
        best_pos = None
        best_len = 0
        
        for pat, positions in patterns.items():
            if i in positions and len(pat) > best_len:
                prev_positions = [p for p in positions if p < i]
                if prev_positions:
                    best_pat = pat
                    best_pos = prev_positions[-1]
                    best_len = len(pat)
        
        if best_pat and best_pos is not None:
            # REF: position + length
            compressed += struct.pack(">HB", best_pos, best_len)
            i += best_len
        else:
            # LITERAL: 1 byte
            compressed.append(data[i])
            i += 1
            
    return compressed</code></pre>
            </div>
            
            <h3>Example 3: File Output</h3>
            <div class="card">
                <p>Compressed data can be saved directly to files:</p>
                <pre><code># Save compressed to file
with open("output.txt", "wb") as f:
    f.write(compressed)

# Read compressed from file
with open("output.txt", "rb") as f:
    compressed_data = f.read()
    decompressed = fsp_decompress(compressed_data)</code></pre>
            </div>
        </section>

        <section id="comparison" class="section">
            <h2><i class="fas fa-balance-scale"></i> Comparison with Other Algorithms</h2>
            
            <table class="comparison-table">
                <tr>
                    <th>Characteristic</th>
                    <th>FSP</th>
                    <th>ZIP</th>
                    <th>RLE</th>
                    <th>LZ77</th>
                </tr>
                <tr>
                    <td>Efficiency for small data</td>
                    <td>Excellent</td>
                    <td>Poor</td>
                    <td>Good</td>
                    <td>Fair</td>
                </tr>
                <tr>
                    <td>Overhead</td>
                    <td>Minimal</td>
                    <td>High</td>
                    <td>Low</td>
                    <td>Medium</td>
                </tr>
                <tr>
                    <td>Implementation complexity</td>
                    <td>Low</td>
                    <td>High</td>
                    <td>Very Low</td>
                    <td>High</td>
                </tr>
                <tr>
                    <td>Compression speed</td>
                    <td>Very High</td>
                    <td>Medium</td>
                    <td>Extremely High</td>
                    <td>Medium</td>
                </tr>
                <tr>
                    <td>Decompression speed</td>
                    <td>Very High</td>
                    <td>Medium</td>
                    <td>Extremely High</td>
                    <td>Medium</td>
                </tr>
                <tr>
                    <td>Compression ratio (repetitive data)</td>
                    <td>Excellent</td>
                    <td>Good</td>
                    <td>Fair</td>
                    <td>Good</td>
                </tr>
                <tr>
                    <td>Pattern adaptability</td>
                    <td>Excellent</td>
                    <td>Good</td>
                    <td>Poor</td>
                    <td>Good</td>
                </tr>
                <tr>
                    <td>Byte-exact storage</td>
                    <td>Yes</td>
                    <td>No</td>
                    <td>Yes</td>
                    <td>No</td>
                </tr>
                <tr>
                    <td>Direct file output</td>
                    <td>Yes</td>
                    <td>No</td>
                    <td>Yes</td>
                    <td>No</td>
                </tr>
            </table>
            
            <div class="card info">
                <h4>Key Differentiators</h4>
                <p>Unlike dictionary methods (LZ77, LZ78), FSP does not require storing a dictionary. Unlike entropy methods (Huffman, Arithmetic), FSP does not require complex probability calculations. This makes FSP uniquely suited for small to medium-sized repetitive data. Version 2.1 adds byte-exact storage and direct file output capabilities.</p>
            </div>
        </section>

        <section id="applications" class="section">
            <h2><i class="fas fa-rocket"></i> Applications</h2>
            
            <h3>Ideal Use Cases</h3>
            <div class="features">
                <div class="feature">
                    <i class="fas fa-code-branch"></i>
                    <h4>Version Control Systems</h4>
                    <p>Storing differences between file versions efficiently</p>
                </div>
                
                <div class="feature">
                    <i class="fas fa-database"></i>
                    <h4>Databases</h4>
                    <p>Compressing similar records with minimal overhead</p>
                </div>
                
                <div class="feature">
                    <i class="fas fa-network-wired"></i>
                    <h4>Network Transmission</h4>
                    <p>Minimizing data transfer volume for repetitive content</p>
                </div>
                
                <div class="feature">
                    <i class="fas fa-file-alt"></i>
                    <h4>Log File Archiving</h4>
                    <p>Efficient compression of highly similar log entries</p>
                </div>
                
                <div class="feature">
                    <i class="fas fa-video"></i>
                    <h4>Video Surveillance</h4>
                    <p>Compressing consecutive frames with minimal changes</p>
                </div>
                
                <div class="feature">
                    <i class="fas fa-dna"></i>
                    <h4>Bioinformatics</h4>
                    <p>Working with DNA/RNA sequences with repeated patterns</p>
                </div>
                
                <div class="feature">
                    <i class="fas fa-history"></i>
                    <h4>Incremental Backups</h4>
                    <p>Storing only changes between backup versions</p>
                </div>
                
                <div class="feature">
                    <i class="fas fa-images"></i>
                    <h4>Image Sets</h4>
                    <p>Compressing sets of images with minor differences</p>
                </div>
            </div>
            
            <h3>Limitations</h3>
            <div class="card warning">
                <ul>
                    <li>Less effective for completely random data with no patterns</li>
                    <li>Requires optimization for very large files (GB+)</li>
                    <li>Efficiency depends on the presence of similar patterns in the data</li>
                    <li>Not yet optimized for real-time streaming applications</li>
                </ul>
            </div>
        </section>

        <section id="changelog" class="section">
            <h2><i class="fas fa-history"></i> Changelog</h2>
            
            <div class="changelog">
                <div class="changelog-version">
                    <h4>Version 2.1 - Next Level FSP (Current)</h4>
                    <ul>
                        <li><strong>Byte-exact storage</strong> - REF and LITERAL are stored as raw bytes for exact size tracking</li>
                        <li><strong>Improved pattern selection</strong> - Automatic minimum pattern length selection between 3-5 characters</li>
                        <li><strong>Minimized REF overhead</strong> - Patterns that repeat only once are stored as LITERAL instead of REF</li>
                        <li><strong>Extended maximum pattern length</strong> - Support for patterns up to 5-6 characters for longer repeats</li>
                        <li><strong>Direct file output</strong> - Compressed data can be saved directly to files (e.g., output.txt)</li>
                        <li><strong>Universal compatibility</strong> - Works for any byte file or stream</li>
                        <li><strong>Cross-language implementation</strong> - Easily implementable in Python, C, C++, Java, Rust, Go, etc.</li>
                        <li><strong>Enhanced compression ratio</strong> - Better compression for various data types</li>
                        <li><strong>LEGO box analogy</strong> - Simple explanation of the algorithm's approach</li>
                        <li><strong>Testable implementation</strong> - Speed measurement for compression and decompression</li>
                    </ul>
                </div>
                
                <div class="changelog-version">
                    <h4>Version 2.0 - Next Level FSP</h4>
                    <ul>
                        <li>Pattern search limited to 3–5 characters to reduce overhead</li>
                        <li>Automatic minimum pattern length selection for maximum repeats</li>
                        <li>Maximum pattern length extended to 5–6 characters for longer repeated sequences</li>
                        <li>Base stream stores concatenated unique patterns</li>
                        <li>References (REF) + literals (LITERAL) replace repeated patterns in text</li>
                        <li>Patterns that repeat only once are stored as LITERAL to minimize REF overhead</li>
                        <li>Works on the entire text, not line-by-line</li>
                        <li>Significantly improved compression ratio</li>
                        <li>Maintains full reversibility</li>
                    </ul>
                </div>
                
                <div class="changelog-version">
                    <h4>Version 1.0 - Original FSP</h4>
                    <ul>
                        <li>Block-based compression approach</li>
                        <li>Pattern search from 2 characters to infinity</li>
                        <li>Base + DIFF per line implementation</li>
                        <li>Simple line-oriented approach</li>
                        <li>Potential for compressed text to grow larger than original for small patterns</li>
                    </ul>
                </div>
            </div>
        </section>

        <div class="footer">
            <p>FSP Algorithm © 2024. All rights reserved.</p>
            <p>Algorithm developed by a 15-year-old programmer</p>
            <p>Licensed under LGPL 3.0</p>
            <p>View project on <a href="https://github.com/Ferki-git-creator/fsp">GitHub</a></p>
        </div>
    </div>

    <script>
        // Smooth scrolling for navigation links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                
                const targetId = this.getAttribute('href');
                const targetElement = document.querySelector(targetId);
                
                if (targetElement) {
                    window.scrollTo({
                        top: targetElement.offsetTop - 20,
                        behavior: 'smooth'
                    });
                }
            });
        });
        
        // Highlight current section in navigation
        window.addEventListener('scroll', function() {
            const sections = document.querySelectorAll('.section');
            const navLinks = document.querySelectorAll('.nav a');
            
            let currentSection = '';
            
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (pageYOffset >= sectionTop - 100) {
                    currentSection = section.getAttribute('id');
                }
            });
            
            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + currentSection) {
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>